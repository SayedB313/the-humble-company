"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@calcom";
exports.ids = ["vendor-chunks/@calcom"];
exports.modules = {

/***/ "(ssr)/./node_modules/@calcom/embed-react/dist/Cal.es.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@calcom/embed-react/dist/Cal.es.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ hr),\n/* harmony export */   getCalApi: () => (/* binding */ Er)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst fr = \"https://app.cal.com/embed/embed.js\";\nfunction X(C = fr) {\n  (function(g, m, y) {\n    let p = function(u, d) {\n      u.q.push(d);\n    }, R = g.document;\n    g.Cal = g.Cal || function() {\n      let u = g.Cal, d = arguments;\n      if (u.loaded || (u.ns = {}, u.q = u.q || [], R.head.appendChild(R.createElement(\"script\")).src = m, u.loaded = !0), d[0] === y) {\n        const l = function() {\n          p(l, arguments);\n        }, b = d[1];\n        l.q = l.q || [], typeof b == \"string\" ? (u.ns[b] = u.ns[b] || l, p(u.ns[b], d), p(u, [\"initNamespace\", b])) : p(u, d);\n        return;\n      }\n      p(u, d);\n    };\n  })(\n    window,\n    //! Replace it with \"https://cal.com/embed.js\" or the URL where you have embed.js installed\n    C,\n    \"init\"\n  );\n  /*!  Copying ends here. */\n  return window.Cal;\n}\nX.toString();\nfunction cr(C) {\n  const [g, m] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    m(() => X(C));\n  }, []), g;\n}\nvar H = { exports: {} }, A = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Te;\nfunction dr() {\n  if (Te)\n    return A;\n  Te = 1;\n  var C = react__WEBPACK_IMPORTED_MODULE_0__, g = Symbol.for(\"react.element\"), m = Symbol.for(\"react.fragment\"), y = Object.prototype.hasOwnProperty, p = C.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, R = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function u(d, l, b) {\n    var f, _ = {}, w = null, $ = null;\n    b !== void 0 && (w = \"\" + b), l.key !== void 0 && (w = \"\" + l.key), l.ref !== void 0 && ($ = l.ref);\n    for (f in l)\n      y.call(l, f) && !R.hasOwnProperty(f) && (_[f] = l[f]);\n    if (d && d.defaultProps)\n      for (f in l = d.defaultProps, l)\n        _[f] === void 0 && (_[f] = l[f]);\n    return { $$typeof: g, type: d, key: w, ref: $, props: _, _owner: p.current };\n  }\n  return A.Fragment = m, A.jsx = u, A.jsxs = u, A;\n}\nvar I = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar we;\nfunction vr() {\n  return we || (we = 1,  true && function() {\n    var C = react__WEBPACK_IMPORTED_MODULE_0__, g = Symbol.for(\"react.element\"), m = Symbol.for(\"react.portal\"), y = Symbol.for(\"react.fragment\"), p = Symbol.for(\"react.strict_mode\"), R = Symbol.for(\"react.profiler\"), u = Symbol.for(\"react.provider\"), d = Symbol.for(\"react.context\"), l = Symbol.for(\"react.forward_ref\"), b = Symbol.for(\"react.suspense\"), f = Symbol.for(\"react.suspense_list\"), _ = Symbol.for(\"react.memo\"), w = Symbol.for(\"react.lazy\"), $ = Symbol.for(\"react.offscreen\"), Z = Symbol.iterator, Pe = \"@@iterator\";\n    function xe(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var r = Z && e[Z] || e[Pe];\n      return typeof r == \"function\" ? r : null;\n    }\n    var x = C.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function h(e) {\n      {\n        for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)\n          t[n - 1] = arguments[n];\n        je(\"error\", e, t);\n      }\n    }\n    function je(e, r, t) {\n      {\n        var n = x.ReactDebugCurrentFrame, o = n.getStackAddendum();\n        o !== \"\" && (r += \"%s\", t = t.concat([o]));\n        var s = t.map(function(i) {\n          return String(i);\n        });\n        s.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, s);\n      }\n    }\n    var ke = !1, De = !1, Fe = !1, Ae = !1, Ie = !1, Q;\n    Q = Symbol.for(\"react.module.reference\");\n    function $e(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === y || e === R || Ie || e === p || e === b || e === f || Ae || e === $ || ke || De || Fe || typeof e == \"object\" && e !== null && (e.$$typeof === w || e.$$typeof === _ || e.$$typeof === u || e.$$typeof === d || e.$$typeof === l || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      e.$$typeof === Q || e.getModuleId !== void 0));\n    }\n    function We(e, r, t) {\n      var n = e.displayName;\n      if (n)\n        return n;\n      var o = r.displayName || r.name || \"\";\n      return o !== \"\" ? t + \"(\" + o + \")\" : t;\n    }\n    function ee(e) {\n      return e.displayName || \"Context\";\n    }\n    function O(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && h(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case y:\n          return \"Fragment\";\n        case m:\n          return \"Portal\";\n        case R:\n          return \"Profiler\";\n        case p:\n          return \"StrictMode\";\n        case b:\n          return \"Suspense\";\n        case f:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case d:\n            var r = e;\n            return ee(r) + \".Consumer\";\n          case u:\n            var t = e;\n            return ee(t._context) + \".Provider\";\n          case l:\n            return We(e, e.render, \"ForwardRef\");\n          case _:\n            var n = e.displayName || null;\n            return n !== null ? n : O(e.type) || \"Memo\";\n          case w: {\n            var o = e, s = o._payload, i = o._init;\n            try {\n              return O(i(s));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var P = Object.assign, D = 0, re, te, ne, ae, ie, oe, ue;\n    function se() {\n    }\n    se.__reactDisabledLog = !0;\n    function Ye() {\n      {\n        if (D === 0) {\n          re = console.log, te = console.info, ne = console.warn, ae = console.error, ie = console.group, oe = console.groupCollapsed, ue = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: se,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        D++;\n      }\n    }\n    function Le() {\n      {\n        if (D--, D === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: P({}, e, {\n              value: re\n            }),\n            info: P({}, e, {\n              value: te\n            }),\n            warn: P({}, e, {\n              value: ne\n            }),\n            error: P({}, e, {\n              value: ae\n            }),\n            group: P({}, e, {\n              value: ie\n            }),\n            groupCollapsed: P({}, e, {\n              value: oe\n            }),\n            groupEnd: P({}, e, {\n              value: ue\n            })\n          });\n        }\n        D < 0 && h(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var V = x.ReactCurrentDispatcher, M;\n    function W(e, r, t) {\n      {\n        if (M === void 0)\n          try {\n            throw Error();\n          } catch (o) {\n            var n = o.stack.trim().match(/\\n( *(at )?)/);\n            M = n && n[1] || \"\";\n          }\n        return `\n` + M + e;\n      }\n    }\n    var q = !1, Y;\n    {\n      var Ne = typeof WeakMap == \"function\" ? WeakMap : Map;\n      Y = new Ne();\n    }\n    function le(e, r) {\n      if (!e || q)\n        return \"\";\n      {\n        var t = Y.get(e);\n        if (t !== void 0)\n          return t;\n      }\n      var n;\n      q = !0;\n      var o = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var s;\n      s = V.current, V.current = null, Ye();\n      try {\n        if (r) {\n          var i = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(i.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(i, []);\n            } catch (S) {\n              n = S;\n            }\n            Reflect.construct(e, [], i);\n          } else {\n            try {\n              i.call();\n            } catch (S) {\n              n = S;\n            }\n            e.call(i.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (S) {\n            n = S;\n          }\n          e();\n        }\n      } catch (S) {\n        if (S && n && typeof S.stack == \"string\") {\n          for (var a = S.stack.split(`\n`), E = n.stack.split(`\n`), c = a.length - 1, v = E.length - 1; c >= 1 && v >= 0 && a[c] !== E[v]; )\n            v--;\n          for (; c >= 1 && v >= 0; c--, v--)\n            if (a[c] !== E[v]) {\n              if (c !== 1 || v !== 1)\n                do\n                  if (c--, v--, v < 0 || a[c] !== E[v]) {\n                    var T = `\n` + a[c].replace(\" at new \", \" at \");\n                    return e.displayName && T.includes(\"<anonymous>\") && (T = T.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && Y.set(e, T), T;\n                  }\n                while (c >= 1 && v >= 0);\n              break;\n            }\n        }\n      } finally {\n        q = !1, V.current = s, Le(), Error.prepareStackTrace = o;\n      }\n      var k = e ? e.displayName || e.name : \"\", _e = k ? W(k) : \"\";\n      return typeof e == \"function\" && Y.set(e, _e), _e;\n    }\n    function Ue(e, r, t) {\n      return le(e, !1);\n    }\n    function Ve(e) {\n      var r = e.prototype;\n      return !!(r && r.isReactComponent);\n    }\n    function L(e, r, t) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return le(e, Ve(e));\n      if (typeof e == \"string\")\n        return W(e);\n      switch (e) {\n        case b:\n          return W(\"Suspense\");\n        case f:\n          return W(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case l:\n            return Ue(e.render);\n          case _:\n            return L(e.type, r, t);\n          case w: {\n            var n = e, o = n._payload, s = n._init;\n            try {\n              return L(s(o), r, t);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var N = Object.prototype.hasOwnProperty, fe = {}, ce = x.ReactDebugCurrentFrame;\n    function U(e) {\n      if (e) {\n        var r = e._owner, t = L(e.type, e._source, r ? r.type : null);\n        ce.setExtraStackFrame(t);\n      } else\n        ce.setExtraStackFrame(null);\n    }\n    function Me(e, r, t, n, o) {\n      {\n        var s = Function.call.bind(N);\n        for (var i in e)\n          if (s(e, i)) {\n            var a = void 0;\n            try {\n              if (typeof e[i] != \"function\") {\n                var E = Error((n || \"React class\") + \": \" + t + \" type `\" + i + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[i] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw E.name = \"Invariant Violation\", E;\n              }\n              a = e[i](r, i, n, t, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (c) {\n              a = c;\n            }\n            a && !(a instanceof Error) && (U(o), h(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", n || \"React class\", t, i, typeof a), U(null)), a instanceof Error && !(a.message in fe) && (fe[a.message] = !0, U(o), h(\"Failed %s type: %s\", t, a.message), U(null));\n          }\n      }\n    }\n    var qe = Array.isArray;\n    function B(e) {\n      return qe(e);\n    }\n    function Be(e) {\n      {\n        var r = typeof Symbol == \"function\" && Symbol.toStringTag, t = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return t;\n      }\n    }\n    function Je(e) {\n      try {\n        return de(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function de(e) {\n      return \"\" + e;\n    }\n    function ve(e) {\n      if (Je(e))\n        return h(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", Be(e)), de(e);\n    }\n    var F = x.ReactCurrentOwner, Ge = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, pe, ge, J;\n    J = {};\n    function ze(e) {\n      if (N.call(e, \"ref\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function Ke(e) {\n      if (N.call(e, \"key\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function He(e, r) {\n      if (typeof e.ref == \"string\" && F.current && r && F.current.stateNode !== r) {\n        var t = O(F.current.type);\n        J[t] || (h('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', O(F.current.type), e.ref), J[t] = !0);\n      }\n    }\n    function Xe(e, r) {\n      {\n        var t = function() {\n          pe || (pe = !0, h(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    function Ze(e, r) {\n      {\n        var t = function() {\n          ge || (ge = !0, h(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    var Qe = function(e, r, t, n, o, s, i) {\n      var a = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: g,\n        // Built-in properties that belong on the element\n        type: e,\n        key: r,\n        ref: t,\n        props: i,\n        // Record the component responsible for creating this element.\n        _owner: s\n      };\n      return a._store = {}, Object.defineProperty(a._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(a, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: n\n      }), Object.defineProperty(a, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: o\n      }), Object.freeze && (Object.freeze(a.props), Object.freeze(a)), a;\n    };\n    function er(e, r, t, n, o) {\n      {\n        var s, i = {}, a = null, E = null;\n        t !== void 0 && (ve(t), a = \"\" + t), Ke(r) && (ve(r.key), a = \"\" + r.key), ze(r) && (E = r.ref, He(r, o));\n        for (s in r)\n          N.call(r, s) && !Ge.hasOwnProperty(s) && (i[s] = r[s]);\n        if (e && e.defaultProps) {\n          var c = e.defaultProps;\n          for (s in c)\n            i[s] === void 0 && (i[s] = c[s]);\n        }\n        if (a || E) {\n          var v = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          a && Xe(i, v), E && Ze(i, v);\n        }\n        return Qe(e, a, E, o, n, F.current, i);\n      }\n    }\n    var G = x.ReactCurrentOwner, me = x.ReactDebugCurrentFrame;\n    function j(e) {\n      if (e) {\n        var r = e._owner, t = L(e.type, e._source, r ? r.type : null);\n        me.setExtraStackFrame(t);\n      } else\n        me.setExtraStackFrame(null);\n    }\n    var z;\n    z = !1;\n    function K(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === g;\n    }\n    function be() {\n      {\n        if (G.current) {\n          var e = O(G.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function rr(e) {\n      {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), t = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + t + \".\";\n        }\n        return \"\";\n      }\n    }\n    var he = {};\n    function tr(e) {\n      {\n        var r = be();\n        if (!r) {\n          var t = typeof e == \"string\" ? e : e.displayName || e.name;\n          t && (r = `\n\nCheck the top-level render call using <` + t + \">.\");\n        }\n        return r;\n      }\n    }\n    function Ee(e, r) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var t = tr(r);\n        if (he[t])\n          return;\n        he[t] = !0;\n        var n = \"\";\n        e && e._owner && e._owner !== G.current && (n = \" It was passed a child from \" + O(e._owner.type) + \".\"), j(e), h('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, n), j(null);\n      }\n    }\n    function ye(e, r) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (B(e))\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];\n            K(n) && Ee(n, r);\n          }\n        else if (K(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var o = xe(e);\n          if (typeof o == \"function\" && o !== e.entries)\n            for (var s = o.call(e), i; !(i = s.next()).done; )\n              K(i.value) && Ee(i.value, r);\n        }\n      }\n    }\n    function nr(e) {\n      {\n        var r = e.type;\n        if (r == null || typeof r == \"string\")\n          return;\n        var t;\n        if (typeof r == \"function\")\n          t = r.propTypes;\n        else if (typeof r == \"object\" && (r.$$typeof === l || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        r.$$typeof === _))\n          t = r.propTypes;\n        else\n          return;\n        if (t) {\n          var n = O(r);\n          Me(t, e.props, \"prop\", n, e);\n        } else if (r.PropTypes !== void 0 && !z) {\n          z = !0;\n          var o = O(r);\n          h(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", o || \"Unknown\");\n        }\n        typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && h(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function ar(e) {\n      {\n        for (var r = Object.keys(e.props), t = 0; t < r.length; t++) {\n          var n = r[t];\n          if (n !== \"children\" && n !== \"key\") {\n            j(e), h(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", n), j(null);\n            break;\n          }\n        }\n        e.ref !== null && (j(e), h(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), j(null));\n      }\n    }\n    function Re(e, r, t, n, o, s) {\n      {\n        var i = $e(e);\n        if (!i) {\n          var a = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (a += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var E = rr(o);\n          E ? a += E : a += be();\n          var c;\n          e === null ? c = \"null\" : B(e) ? c = \"array\" : e !== void 0 && e.$$typeof === g ? (c = \"<\" + (O(e.type) || \"Unknown\") + \" />\", a = \" Did you accidentally export a JSX literal instead of a component?\") : c = typeof e, h(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", c, a);\n        }\n        var v = er(e, r, t, o, s);\n        if (v == null)\n          return v;\n        if (i) {\n          var T = r.children;\n          if (T !== void 0)\n            if (n)\n              if (B(T)) {\n                for (var k = 0; k < T.length; k++)\n                  ye(T[k], e);\n                Object.freeze && Object.freeze(T);\n              } else\n                h(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              ye(T, e);\n        }\n        return e === y ? ar(v) : nr(v), v;\n      }\n    }\n    function ir(e, r, t) {\n      return Re(e, r, t, !0);\n    }\n    function or(e, r, t) {\n      return Re(e, r, t, !1);\n    }\n    var ur = or, sr = ir;\n    I.Fragment = y, I.jsx = ur, I.jsxs = sr;\n  }()), I;\n}\n false ? 0 : H.exports = vr();\nvar pr = H.exports;\nconst gr = pr.jsx, mr = function(g) {\n  const {\n    calLink: m,\n    calOrigin: y,\n    namespace: p = \"\",\n    config: R,\n    initConfig: u = {},\n    embedJsUrl: d,\n    ...l\n  } = g;\n  if (!m)\n    throw new Error(\"calLink is required\");\n  const b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), f = cr(d), _ = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!f || b.current || !_.current)\n      return;\n    b.current = !0;\n    const w = _.current;\n    p ? (f(\"init\", p, {\n      ...u,\n      origin: y\n    }), f.ns[p](\"inline\", {\n      elementOrSelector: w,\n      calLink: m,\n      config: R\n    })) : (f(\"init\", {\n      ...u,\n      origin: y\n    }), f(\"inline\", {\n      elementOrSelector: w,\n      calLink: m,\n      config: R\n    }));\n  }, [f, m, R, p, y, u]), f ? /* @__PURE__ */ gr(\"div\", {\n    ref: _,\n    ...l\n  }) : null;\n}, hr = mr;\nfunction Er(C) {\n  const g = typeof C == \"string\" ? { embedJsUrl: C } : C ?? {}, { namespace: m = \"\", embedJsUrl: y } = g;\n  return new Promise(function p(R) {\n    const u = X(y);\n    u(\"init\", m);\n    const d = m ? u.ns[m] : u;\n    if (!d) {\n      setTimeout(() => {\n        p(R);\n      }, 50);\n      return;\n    }\n    R(d);\n  });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhbGNvbS9lbWJlZC1yZWFjdC9kaXN0L0NhbC5lcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQUU7QUFDbkIsU0FBUyxnREFBRTtBQUNYO0FBQ0EsR0FBRztBQUNIO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFFLDRMQUE0TDtBQUN4TTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdELFlBQVksa0NBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQztBQUNoQztBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQ0FBbUM7QUFDM0U7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE1BQXFDLEdBQUcsQ0FBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBWSw2Q0FBRSxxQkFBcUIsNkNBQUU7QUFDckMsU0FBUyxnREFBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxxQ0FBcUMsZ0JBQWdCLFNBQVMsSUFBSSxtQ0FBbUM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZWN0b3Itc3VtbWl0Ly4vbm9kZV9tb2R1bGVzL0BjYWxjb20vZW1iZWQtcmVhY3QvZGlzdC9DYWwuZXMubWpzP2ZiNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9lLCB7IHVzZVN0YXRlIGFzIGxyLCB1c2VFZmZlY3QgYXMgU2UsIHVzZVJlZiBhcyBDZSB9IGZyb20gXCJyZWFjdFwiO1xuY29uc3QgZnIgPSBcImh0dHBzOi8vYXBwLmNhbC5jb20vZW1iZWQvZW1iZWQuanNcIjtcbmZ1bmN0aW9uIFgoQyA9IGZyKSB7XG4gIChmdW5jdGlvbihnLCBtLCB5KSB7XG4gICAgbGV0IHAgPSBmdW5jdGlvbih1LCBkKSB7XG4gICAgICB1LnEucHVzaChkKTtcbiAgICB9LCBSID0gZy5kb2N1bWVudDtcbiAgICBnLkNhbCA9IGcuQ2FsIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IHUgPSBnLkNhbCwgZCA9IGFyZ3VtZW50cztcbiAgICAgIGlmICh1LmxvYWRlZCB8fCAodS5ucyA9IHt9LCB1LnEgPSB1LnEgfHwgW10sIFIuaGVhZC5hcHBlbmRDaGlsZChSLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpLnNyYyA9IG0sIHUubG9hZGVkID0gITApLCBkWzBdID09PSB5KSB7XG4gICAgICAgIGNvbnN0IGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBwKGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGIgPSBkWzFdO1xuICAgICAgICBsLnEgPSBsLnEgfHwgW10sIHR5cGVvZiBiID09IFwic3RyaW5nXCIgPyAodS5uc1tiXSA9IHUubnNbYl0gfHwgbCwgcCh1Lm5zW2JdLCBkKSwgcCh1LCBbXCJpbml0TmFtZXNwYWNlXCIsIGJdKSkgOiBwKHUsIGQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwKHUsIGQpO1xuICAgIH07XG4gIH0pKFxuICAgIHdpbmRvdyxcbiAgICAvLyEgUmVwbGFjZSBpdCB3aXRoIFwiaHR0cHM6Ly9jYWwuY29tL2VtYmVkLmpzXCIgb3IgdGhlIFVSTCB3aGVyZSB5b3UgaGF2ZSBlbWJlZC5qcyBpbnN0YWxsZWRcbiAgICBDLFxuICAgIFwiaW5pdFwiXG4gICk7XG4gIC8qISAgQ29weWluZyBlbmRzIGhlcmUuICovXG4gIHJldHVybiB3aW5kb3cuQ2FsO1xufVxuWC50b1N0cmluZygpO1xuZnVuY3Rpb24gY3IoQykge1xuICBjb25zdCBbZywgbV0gPSBscigpO1xuICByZXR1cm4gU2UoKCkgPT4ge1xuICAgIG0oKCkgPT4gWChDKSk7XG4gIH0sIFtdKSwgZztcbn1cbnZhciBIID0geyBleHBvcnRzOiB7fSB9LCBBID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgVGU7XG5mdW5jdGlvbiBkcigpIHtcbiAgaWYgKFRlKVxuICAgIHJldHVybiBBO1xuICBUZSA9IDE7XG4gIHZhciBDID0gT2UsIGcgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgeSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIHAgPSBDLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCBSID0geyBrZXk6ICEwLCByZWY6ICEwLCBfX3NlbGY6ICEwLCBfX3NvdXJjZTogITAgfTtcbiAgZnVuY3Rpb24gdShkLCBsLCBiKSB7XG4gICAgdmFyIGYsIF8gPSB7fSwgdyA9IG51bGwsICQgPSBudWxsO1xuICAgIGIgIT09IHZvaWQgMCAmJiAodyA9IFwiXCIgKyBiKSwgbC5rZXkgIT09IHZvaWQgMCAmJiAodyA9IFwiXCIgKyBsLmtleSksIGwucmVmICE9PSB2b2lkIDAgJiYgKCQgPSBsLnJlZik7XG4gICAgZm9yIChmIGluIGwpXG4gICAgICB5LmNhbGwobCwgZikgJiYgIVIuaGFzT3duUHJvcGVydHkoZikgJiYgKF9bZl0gPSBsW2ZdKTtcbiAgICBpZiAoZCAmJiBkLmRlZmF1bHRQcm9wcylcbiAgICAgIGZvciAoZiBpbiBsID0gZC5kZWZhdWx0UHJvcHMsIGwpXG4gICAgICAgIF9bZl0gPT09IHZvaWQgMCAmJiAoX1tmXSA9IGxbZl0pO1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiBnLCB0eXBlOiBkLCBrZXk6IHcsIHJlZjogJCwgcHJvcHM6IF8sIF9vd25lcjogcC5jdXJyZW50IH07XG4gIH1cbiAgcmV0dXJuIEEuRnJhZ21lbnQgPSBtLCBBLmpzeCA9IHUsIEEuanN4cyA9IHUsIEE7XG59XG52YXIgSSA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIHdlO1xuZnVuY3Rpb24gdnIoKSB7XG4gIHJldHVybiB3ZSB8fCAod2UgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIEMgPSBPZSwgZyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBtID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgeSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgcCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgUiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgdSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgZCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBsID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBiID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBmID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIF8gPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgdyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCAkID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgWiA9IFN5bWJvbC5pdGVyYXRvciwgUGUgPSBcIkBAaXRlcmF0b3JcIjtcbiAgICBmdW5jdGlvbiB4ZShlKSB7XG4gICAgICBpZiAoZSA9PT0gbnVsbCB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciByID0gWiAmJiBlW1pdIHx8IGVbUGVdO1xuICAgICAgcmV0dXJuIHR5cGVvZiByID09IFwiZnVuY3Rpb25cIiA/IHIgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgeCA9IEMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gICAgZnVuY3Rpb24gaChlKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KHIgPiAxID8gciAtIDEgOiAwKSwgbiA9IDE7IG4gPCByOyBuKyspXG4gICAgICAgICAgdFtuIC0gMV0gPSBhcmd1bWVudHNbbl07XG4gICAgICAgIGplKFwiZXJyb3JcIiwgZSwgdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGplKGUsIHIsIHQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIG4gPSB4LlJlYWN0RGVidWdDdXJyZW50RnJhbWUsIG8gPSBuLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgbyAhPT0gXCJcIiAmJiAociArPSBcIiVzXCIsIHQgPSB0LmNvbmNhdChbb10pKTtcbiAgICAgICAgdmFyIHMgPSB0Lm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHMudW5zaGlmdChcIldhcm5pbmc6IFwiICsgciksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbZV0sIGNvbnNvbGUsIHMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIga2UgPSAhMSwgRGUgPSAhMSwgRmUgPSAhMSwgQWUgPSAhMSwgSWUgPSAhMSwgUTtcbiAgICBRID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gICAgZnVuY3Rpb24gJGUoZSkge1xuICAgICAgcmV0dXJuICEhKHR5cGVvZiBlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiIHx8IGUgPT09IHkgfHwgZSA9PT0gUiB8fCBJZSB8fCBlID09PSBwIHx8IGUgPT09IGIgfHwgZSA9PT0gZiB8fCBBZSB8fCBlID09PSAkIHx8IGtlIHx8IERlIHx8IEZlIHx8IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiAoZS4kJHR5cGVvZiA9PT0gdyB8fCBlLiQkdHlwZW9mID09PSBfIHx8IGUuJCR0eXBlb2YgPT09IHUgfHwgZS4kJHR5cGVvZiA9PT0gZCB8fCBlLiQkdHlwZW9mID09PSBsIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgICAgLy8gd2l0aC5cbiAgICAgIGUuJCR0eXBlb2YgPT09IFEgfHwgZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdlKGUsIHIsIHQpIHtcbiAgICAgIHZhciBuID0gZS5kaXNwbGF5TmFtZTtcbiAgICAgIGlmIChuKVxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIHZhciBvID0gci5kaXNwbGF5TmFtZSB8fCByLm5hbWUgfHwgXCJcIjtcbiAgICAgIHJldHVybiBvICE9PSBcIlwiID8gdCArIFwiKFwiICsgbyArIFwiKVwiIDogdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWUoZSkge1xuICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE8oZSkge1xuICAgICAgaWYgKGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIGUudGFnID09IFwibnVtYmVyXCIgJiYgaChcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpLCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgeTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIG06XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgUjpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIHA6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBmOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAoZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgZDpcbiAgICAgICAgICAgIHZhciByID0gZTtcbiAgICAgICAgICAgIHJldHVybiBlZShyKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgdmFyIHQgPSBlO1xuICAgICAgICAgICAgcmV0dXJuIGVlKHQuX2NvbnRleHQpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgICByZXR1cm4gV2UoZSwgZS5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICBjYXNlIF86XG4gICAgICAgICAgICB2YXIgbiA9IGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBuICE9PSBudWxsID8gbiA6IE8oZS50eXBlKSB8fCBcIk1lbW9cIjtcbiAgICAgICAgICBjYXNlIHc6IHtcbiAgICAgICAgICAgIHZhciBvID0gZSwgcyA9IG8uX3BheWxvYWQsIGkgPSBvLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIE8oaShzKSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIFAgPSBPYmplY3QuYXNzaWduLCBEID0gMCwgcmUsIHRlLCBuZSwgYWUsIGllLCBvZSwgdWU7XG4gICAgZnVuY3Rpb24gc2UoKSB7XG4gICAgfVxuICAgIHNlLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIGZ1bmN0aW9uIFllKCkge1xuICAgICAge1xuICAgICAgICBpZiAoRCA9PT0gMCkge1xuICAgICAgICAgIHJlID0gY29uc29sZS5sb2csIHRlID0gY29uc29sZS5pbmZvLCBuZSA9IGNvbnNvbGUud2FybiwgYWUgPSBjb25zb2xlLmVycm9yLCBpZSA9IGNvbnNvbGUuZ3JvdXAsIG9lID0gY29uc29sZS5ncm91cENvbGxhcHNlZCwgdWUgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgdmFsdWU6IHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBpbmZvOiBlLFxuICAgICAgICAgICAgbG9nOiBlLFxuICAgICAgICAgICAgd2FybjogZSxcbiAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgZ3JvdXA6IGUsXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogZSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgRCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBMZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEQtLSwgRCA9PT0gMCkge1xuICAgICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBsb2c6IFAoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZm86IFAoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm46IFAoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG5lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVycm9yOiBQKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBhZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cDogUCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogaWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IFAoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG9lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBQKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBEIDwgMCAmJiBoKFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFYgPSB4LlJlYWN0Q3VycmVudERpc3BhdGNoZXIsIE07XG4gICAgZnVuY3Rpb24gVyhlLCByLCB0KSB7XG4gICAgICB7XG4gICAgICAgIGlmIChNID09PSB2b2lkIDApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICAgICAgdmFyIG4gPSBvLnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgICAgTSA9IG4gJiYgblsxXSB8fCBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBcbmAgKyBNICsgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHEgPSAhMSwgWTtcbiAgICB7XG4gICAgICB2YXIgTmUgPSB0eXBlb2YgV2Vha01hcCA9PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogTWFwO1xuICAgICAgWSA9IG5ldyBOZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZShlLCByKSB7XG4gICAgICBpZiAoIWUgfHwgcSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB7XG4gICAgICAgIHZhciB0ID0gWS5nZXQoZSk7XG4gICAgICAgIGlmICh0ICE9PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgICB2YXIgbjtcbiAgICAgIHEgPSAhMDtcbiAgICAgIHZhciBvID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBzO1xuICAgICAgcyA9IFYuY3VycmVudCwgVi5jdXJyZW50ID0gbnVsbCwgWWUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgdmFyIGkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KGkucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIHR5cGVvZiBSZWZsZWN0ID09IFwib2JqZWN0XCIgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGksIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKFMpIHtcbiAgICAgICAgICAgICAgbiA9IFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChlLCBbXSwgaSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGkuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoUykge1xuICAgICAgICAgICAgICBuID0gUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUuY2FsbChpLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKFMpIHtcbiAgICAgICAgICAgIG4gPSBTO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKFMpIHtcbiAgICAgICAgaWYgKFMgJiYgbiAmJiB0eXBlb2YgUy5zdGFjayA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IFMuc3RhY2suc3BsaXQoYFxuYCksIEUgPSBuLnN0YWNrLnNwbGl0KGBcbmApLCBjID0gYS5sZW5ndGggLSAxLCB2ID0gRS5sZW5ndGggLSAxOyBjID49IDEgJiYgdiA+PSAwICYmIGFbY10gIT09IEVbdl07IClcbiAgICAgICAgICAgIHYtLTtcbiAgICAgICAgICBmb3IgKDsgYyA+PSAxICYmIHYgPj0gMDsgYy0tLCB2LS0pXG4gICAgICAgICAgICBpZiAoYVtjXSAhPT0gRVt2XSkge1xuICAgICAgICAgICAgICBpZiAoYyAhPT0gMSB8fCB2ICE9PSAxKVxuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoYy0tLCB2LS0sIHYgPCAwIHx8IGFbY10gIT09IEVbdl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFQgPSBgXG5gICsgYVtjXS5yZXBsYWNlKFwiIGF0IG5ldyBcIiwgXCIgYXQgXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5kaXNwbGF5TmFtZSAmJiBULmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiYgKFQgPSBULnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBlLmRpc3BsYXlOYW1lKSksIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiAmJiBZLnNldChlLCBUKSwgVDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoYyA+PSAxICYmIHYgPj0gMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBxID0gITEsIFYuY3VycmVudCA9IHMsIExlKCksIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gbztcbiAgICAgIH1cbiAgICAgIHZhciBrID0gZSA/IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lIDogXCJcIiwgX2UgPSBrID8gVyhrKSA6IFwiXCI7XG4gICAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIFkuc2V0KGUsIF9lKSwgX2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVlKGUsIHIsIHQpIHtcbiAgICAgIHJldHVybiBsZShlLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZlKGUpIHtcbiAgICAgIHZhciByID0gZS5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gISEociAmJiByLmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMKGUsIHIsIHQpIHtcbiAgICAgIGlmIChlID09IG51bGwpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGxlKGUsIFZlKGUpKTtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gVyhlKTtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgcmV0dXJuIFcoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSBmOlxuICAgICAgICAgIHJldHVybiBXKFwiU3VzcGVuc2VMaXN0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAoZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgIHJldHVybiBVZShlLnJlbmRlcik7XG4gICAgICAgICAgY2FzZSBfOlxuICAgICAgICAgICAgcmV0dXJuIEwoZS50eXBlLCByLCB0KTtcbiAgICAgICAgICBjYXNlIHc6IHtcbiAgICAgICAgICAgIHZhciBuID0gZSwgbyA9IG4uX3BheWxvYWQsIHMgPSBuLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIEwocyhvKSwgciwgdCk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgTiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGZlID0ge30sIGNlID0geC5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIFUoZSkge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdmFyIHIgPSBlLl9vd25lciwgdCA9IEwoZS50eXBlLCBlLl9zb3VyY2UsIHIgPyByLnR5cGUgOiBudWxsKTtcbiAgICAgICAgY2Uuc2V0RXh0cmFTdGFja0ZyYW1lKHQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGNlLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTWUoZSwgciwgdCwgbiwgbykge1xuICAgICAge1xuICAgICAgICB2YXIgcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChOKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBlKVxuICAgICAgICAgIGlmIChzKGUsIGkpKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZVtpXSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgRSA9IEVycm9yKChuIHx8IFwiUmVhY3QgY2xhc3NcIikgKyBcIjogXCIgKyB0ICsgXCIgdHlwZSBgXCIgKyBpICsgXCJgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGBcIiArIHR5cGVvZiBlW2ldICsgXCJgLlRoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLlwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBFLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgRTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhID0gZVtpXShyLCBpLCBuLCB0LCBudWxsLCBcIlNFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoYykge1xuICAgICAgICAgICAgICBhID0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgJiYgIShhIGluc3RhbmNlb2YgRXJyb3IpICYmIChVKG8pLCBoKFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCBuIHx8IFwiUmVhY3QgY2xhc3NcIiwgdCwgaSwgdHlwZW9mIGEpLCBVKG51bGwpKSwgYSBpbnN0YW5jZW9mIEVycm9yICYmICEoYS5tZXNzYWdlIGluIGZlKSAmJiAoZmVbYS5tZXNzYWdlXSA9ICEwLCBVKG8pLCBoKFwiRmFpbGVkICVzIHR5cGU6ICVzXCIsIHQsIGEubWVzc2FnZSksIFUobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHFlID0gQXJyYXkuaXNBcnJheTtcbiAgICBmdW5jdGlvbiBCKGUpIHtcbiAgICAgIHJldHVybiBxZShlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQmUoZSkge1xuICAgICAge1xuICAgICAgICB2YXIgciA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZywgdCA9IHIgJiYgZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IGUuY29uc3RydWN0b3IubmFtZSB8fCBcIk9iamVjdFwiO1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gSmUoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlKGUpLCAhMTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlKGUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmUoZSkge1xuICAgICAgaWYgKEplKGUpKVxuICAgICAgICByZXR1cm4gaChcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLCBCZShlKSksIGRlKGUpO1xuICAgIH1cbiAgICB2YXIgRiA9IHguUmVhY3RDdXJyZW50T3duZXIsIEdlID0ge1xuICAgICAga2V5OiAhMCxcbiAgICAgIHJlZjogITAsXG4gICAgICBfX3NlbGY6ICEwLFxuICAgICAgX19zb3VyY2U6ICEwXG4gICAgfSwgcGUsIGdlLCBKO1xuICAgIEogPSB7fTtcbiAgICBmdW5jdGlvbiB6ZShlKSB7XG4gICAgICBpZiAoTi5jYWxsKGUsIFwicmVmXCIpKSB7XG4gICAgICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBcInJlZlwiKS5nZXQ7XG4gICAgICAgIGlmIChyICYmIHIuaXNSZWFjdFdhcm5pbmcpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGUucmVmICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEtlKGUpIHtcbiAgICAgIGlmIChOLmNhbGwoZSwgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKHIgJiYgci5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5rZXkgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gSGUoZSwgcikge1xuICAgICAgaWYgKHR5cGVvZiBlLnJlZiA9PSBcInN0cmluZ1wiICYmIEYuY3VycmVudCAmJiByICYmIEYuY3VycmVudC5zdGF0ZU5vZGUgIT09IHIpIHtcbiAgICAgICAgdmFyIHQgPSBPKEYuY3VycmVudC50eXBlKTtcbiAgICAgICAgSlt0XSB8fCAoaCgnQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuIFN1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiBXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIE8oRi5jdXJyZW50LnR5cGUpLCBlLnJlZiksIEpbdF0gPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFhlKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBwZSB8fCAocGUgPSAhMCwgaChcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIHIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdC5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJrZXlcIiwge1xuICAgICAgICAgIGdldDogdCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBaZShlLCByKSB7XG4gICAgICB7XG4gICAgICAgIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZ2UgfHwgKGdlID0gITAsIGgoXCIlczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCByKSk7XG4gICAgICAgIH07XG4gICAgICAgIHQuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicmVmXCIsIHtcbiAgICAgICAgICBnZXQ6IHQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFFlID0gZnVuY3Rpb24oZSwgciwgdCwgbiwgbywgcywgaSkge1xuICAgICAgdmFyIGEgPSB7XG4gICAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgICAkJHR5cGVvZjogZyxcbiAgICAgICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgICAgICB0eXBlOiBlLFxuICAgICAgICBrZXk6IHIsXG4gICAgICAgIHJlZjogdCxcbiAgICAgICAgcHJvcHM6IGksXG4gICAgICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgICAgIF9vd25lcjogc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBhLl9zdG9yZSA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6ICExXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIFwiX3NlbGZcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogblxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcIl9zb3VyY2VcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogb1xuICAgICAgfSksIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUoYS5wcm9wcyksIE9iamVjdC5mcmVlemUoYSkpLCBhO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZXIoZSwgciwgdCwgbiwgbykge1xuICAgICAge1xuICAgICAgICB2YXIgcywgaSA9IHt9LCBhID0gbnVsbCwgRSA9IG51bGw7XG4gICAgICAgIHQgIT09IHZvaWQgMCAmJiAodmUodCksIGEgPSBcIlwiICsgdCksIEtlKHIpICYmICh2ZShyLmtleSksIGEgPSBcIlwiICsgci5rZXkpLCB6ZShyKSAmJiAoRSA9IHIucmVmLCBIZShyLCBvKSk7XG4gICAgICAgIGZvciAocyBpbiByKVxuICAgICAgICAgIE4uY2FsbChyLCBzKSAmJiAhR2UuaGFzT3duUHJvcGVydHkocykgJiYgKGlbc10gPSByW3NdKTtcbiAgICAgICAgaWYgKGUgJiYgZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgYyA9IGUuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGZvciAocyBpbiBjKVxuICAgICAgICAgICAgaVtzXSA9PT0gdm9pZCAwICYmIChpW3NdID0gY1tzXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgfHwgRSkge1xuICAgICAgICAgIHZhciB2ID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgfHwgXCJVbmtub3duXCIgOiBlO1xuICAgICAgICAgIGEgJiYgWGUoaSwgdiksIEUgJiYgWmUoaSwgdik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFFlKGUsIGEsIEUsIG8sIG4sIEYuY3VycmVudCwgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBHID0geC5SZWFjdEN1cnJlbnRPd25lciwgbWUgPSB4LlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gaihlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICB2YXIgciA9IGUuX293bmVyLCB0ID0gTChlLnR5cGUsIGUuX3NvdXJjZSwgciA/IHIudHlwZSA6IG51bGwpO1xuICAgICAgICBtZS5zZXRFeHRyYVN0YWNrRnJhbWUodCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICB2YXIgejtcbiAgICB6ID0gITE7XG4gICAgZnVuY3Rpb24gSyhlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIGUuJCR0eXBlb2YgPT09IGc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJlKCkge1xuICAgICAge1xuICAgICAgICBpZiAoRy5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIGUgPSBPKEcuY3VycmVudC50eXBlKTtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFxcYGAgKyBlICsgXCJgLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBycihlKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgciA9IGUuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgXCJcIiksIHQgPSBlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgeW91ciBjb2RlIGF0IGAgKyByICsgXCI6XCIgKyB0ICsgXCIuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBoZSA9IHt9O1xuICAgIGZ1bmN0aW9uIHRyKGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHIgPSBiZSgpO1xuICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICB2YXIgdCA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWU7XG4gICAgICAgICAgdCAmJiAociA9IGBcblxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8YCArIHQgKyBcIj4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBFZShlLCByKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghZS5fc3RvcmUgfHwgZS5fc3RvcmUudmFsaWRhdGVkIHx8IGUua2V5ICE9IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlLl9zdG9yZS52YWxpZGF0ZWQgPSAhMDtcbiAgICAgICAgdmFyIHQgPSB0cihyKTtcbiAgICAgICAgaWYgKGhlW3RdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaGVbdF0gPSAhMDtcbiAgICAgICAgdmFyIG4gPSBcIlwiO1xuICAgICAgICBlICYmIGUuX293bmVyICYmIGUuX293bmVyICE9PSBHLmN1cnJlbnQgJiYgKG4gPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIE8oZS5fb3duZXIudHlwZSkgKyBcIi5cIiksIGooZSksIGgoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4lcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIHQsIG4pLCBqKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB5ZShlLCByKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKEIoZSkpXG4gICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGVbdF07XG4gICAgICAgICAgICBLKG4pICYmIEVlKG4sIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoSyhlKSlcbiAgICAgICAgICBlLl9zdG9yZSAmJiAoZS5fc3RvcmUudmFsaWRhdGVkID0gITApO1xuICAgICAgICBlbHNlIGlmIChlKSB7XG4gICAgICAgICAgdmFyIG8gPSB4ZShlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiICYmIG8gIT09IGUuZW50cmllcylcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSBvLmNhbGwoZSksIGk7ICEoaSA9IHMubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgICAgIEsoaS52YWx1ZSkgJiYgRWUoaS52YWx1ZSwgcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbnIoZSkge1xuICAgICAge1xuICAgICAgICB2YXIgciA9IGUudHlwZTtcbiAgICAgICAgaWYgKHIgPT0gbnVsbCB8fCB0eXBlb2YgciA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGlmICh0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdCA9IHIucHJvcFR5cGVzO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgciA9PSBcIm9iamVjdFwiICYmIChyLiQkdHlwZW9mID09PSBsIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAgICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgICAgIHIuJCR0eXBlb2YgPT09IF8pKVxuICAgICAgICAgIHQgPSByLnByb3BUeXBlcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICB2YXIgbiA9IE8ocik7XG4gICAgICAgICAgTWUodCwgZS5wcm9wcywgXCJwcm9wXCIsIG4sIGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHIuUHJvcFR5cGVzICE9PSB2b2lkIDAgJiYgIXopIHtcbiAgICAgICAgICB6ID0gITA7XG4gICAgICAgICAgdmFyIG8gPSBPKHIpO1xuICAgICAgICAgIGgoXCJDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD9cIiwgbyB8fCBcIlVua25vd25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZW9mIHIuZ2V0RGVmYXVsdFByb3BzID09IFwiZnVuY3Rpb25cIiAmJiAhci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgaChcImdldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyBkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcihlKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIHIgPSBPYmplY3Qua2V5cyhlLnByb3BzKSwgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgdmFyIG4gPSByW3RdO1xuICAgICAgICAgIGlmIChuICE9PSBcImNoaWxkcmVuXCIgJiYgbiAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgaihlKSwgaChcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIG4pLCBqKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGUucmVmICE9PSBudWxsICYmIChqKGUpLCBoKFwiSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC5cIiksIGoobnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZShlLCByLCB0LCBuLCBvLCBzKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBpID0gJGUoZSk7XG4gICAgICAgIGlmICghaSkge1xuICAgICAgICAgIHZhciBhID0gXCJcIjtcbiAgICAgICAgICAoZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPT09IDApICYmIChhICs9IFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIik7XG4gICAgICAgICAgdmFyIEUgPSBycihvKTtcbiAgICAgICAgICBFID8gYSArPSBFIDogYSArPSBiZSgpO1xuICAgICAgICAgIHZhciBjO1xuICAgICAgICAgIGUgPT09IG51bGwgPyBjID0gXCJudWxsXCIgOiBCKGUpID8gYyA9IFwiYXJyYXlcIiA6IGUgIT09IHZvaWQgMCAmJiBlLiQkdHlwZW9mID09PSBnID8gKGMgPSBcIjxcIiArIChPKGUudHlwZSkgfHwgXCJVbmtub3duXCIpICsgXCIgLz5cIiwgYSA9IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpIDogYyA9IHR5cGVvZiBlLCBoKFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsIGMsIGEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ID0gZXIoZSwgciwgdCwgbywgcyk7XG4gICAgICAgIGlmICh2ID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgdmFyIFQgPSByLmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChUICE9PSB2b2lkIDApXG4gICAgICAgICAgICBpZiAobilcbiAgICAgICAgICAgICAgaWYgKEIoVCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IFQubGVuZ3RoOyBrKyspXG4gICAgICAgICAgICAgICAgICB5ZShUW2tdLCBlKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoVCk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGgoXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB5ZShULCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSA9PT0geSA/IGFyKHYpIDogbnIodiksIHY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlyKGUsIHIsIHQpIHtcbiAgICAgIHJldHVybiBSZShlLCByLCB0LCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9yKGUsIHIsIHQpIHtcbiAgICAgIHJldHVybiBSZShlLCByLCB0LCAhMSk7XG4gICAgfVxuICAgIHZhciB1ciA9IG9yLCBzciA9IGlyO1xuICAgIEkuRnJhZ21lbnQgPSB5LCBJLmpzeCA9IHVyLCBJLmpzeHMgPSBzcjtcbiAgfSgpKSwgSTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IEguZXhwb3J0cyA9IGRyKCkgOiBILmV4cG9ydHMgPSB2cigpO1xudmFyIHByID0gSC5leHBvcnRzO1xuY29uc3QgZ3IgPSBwci5qc3gsIG1yID0gZnVuY3Rpb24oZykge1xuICBjb25zdCB7XG4gICAgY2FsTGluazogbSxcbiAgICBjYWxPcmlnaW46IHksXG4gICAgbmFtZXNwYWNlOiBwID0gXCJcIixcbiAgICBjb25maWc6IFIsXG4gICAgaW5pdENvbmZpZzogdSA9IHt9LFxuICAgIGVtYmVkSnNVcmw6IGQsXG4gICAgLi4ubFxuICB9ID0gZztcbiAgaWYgKCFtKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNhbExpbmsgaXMgcmVxdWlyZWRcIik7XG4gIGNvbnN0IGIgPSBDZSghMSksIGYgPSBjcihkKSwgXyA9IENlKG51bGwpO1xuICByZXR1cm4gU2UoKCkgPT4ge1xuICAgIGlmICghZiB8fCBiLmN1cnJlbnQgfHwgIV8uY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBiLmN1cnJlbnQgPSAhMDtcbiAgICBjb25zdCB3ID0gXy5jdXJyZW50O1xuICAgIHAgPyAoZihcImluaXRcIiwgcCwge1xuICAgICAgLi4udSxcbiAgICAgIG9yaWdpbjogeVxuICAgIH0pLCBmLm5zW3BdKFwiaW5saW5lXCIsIHtcbiAgICAgIGVsZW1lbnRPclNlbGVjdG9yOiB3LFxuICAgICAgY2FsTGluazogbSxcbiAgICAgIGNvbmZpZzogUlxuICAgIH0pKSA6IChmKFwiaW5pdFwiLCB7XG4gICAgICAuLi51LFxuICAgICAgb3JpZ2luOiB5XG4gICAgfSksIGYoXCJpbmxpbmVcIiwge1xuICAgICAgZWxlbWVudE9yU2VsZWN0b3I6IHcsXG4gICAgICBjYWxMaW5rOiBtLFxuICAgICAgY29uZmlnOiBSXG4gICAgfSkpO1xuICB9LCBbZiwgbSwgUiwgcCwgeSwgdV0pLCBmID8gLyogQF9fUFVSRV9fICovIGdyKFwiZGl2XCIsIHtcbiAgICByZWY6IF8sXG4gICAgLi4ubFxuICB9KSA6IG51bGw7XG59LCBociA9IG1yO1xuZnVuY3Rpb24gRXIoQykge1xuICBjb25zdCBnID0gdHlwZW9mIEMgPT0gXCJzdHJpbmdcIiA/IHsgZW1iZWRKc1VybDogQyB9IDogQyA/PyB7fSwgeyBuYW1lc3BhY2U6IG0gPSBcIlwiLCBlbWJlZEpzVXJsOiB5IH0gPSBnO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gcChSKSB7XG4gICAgY29uc3QgdSA9IFgoeSk7XG4gICAgdShcImluaXRcIiwgbSk7XG4gICAgY29uc3QgZCA9IG0gPyB1Lm5zW21dIDogdTtcbiAgICBpZiAoIWQpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBwKFIpO1xuICAgICAgfSwgNTApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBSKGQpO1xuICB9KTtcbn1cbmV4cG9ydCB7XG4gIGhyIGFzIGRlZmF1bHQsXG4gIEVyIGFzIGdldENhbEFwaVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@calcom/embed-react/dist/Cal.es.mjs\n");

/***/ })

};
;